<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>nestjs接入动态配置</title>
    <link href="/2025/09/17/nestjs%E6%8E%A5%E5%85%A5%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE/"/>
    <url>/2025/09/17/nestjs%E6%8E%A5%E5%85%A5%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>动态配置</p>]]></content>
    
    
    
    <tags>
      
      <tag>nestjs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nestjs接入配置、数据库和验证</title>
    <link href="/2025/09/15/nestjs%E6%8E%A5%E5%85%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%81MONGO%E5%92%8C%E9%AA%8C%E8%AF%81/"/>
    <url>/2025/09/15/nestjs%E6%8E%A5%E5%85%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%81MONGO%E5%92%8C%E9%AA%8C%E8%AF%81/</url>
    
    <content type="html"><![CDATA[<h2 id="nestjs接入数据库"><a href="#nestjs接入数据库" class="headerlink" title="nestjs接入数据库"></a>nestjs接入数据库</h2><h3 id="TypeORM-集成"><a href="#TypeORM-集成" class="headerlink" title="TypeORM 集成"></a>TypeORM 集成</h3><p>安装所需的依赖项</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install --save @nestjs/typeorm typeorm mysql2<br></code></pre></td></tr></table></figure><p>安装完成后，我们可以把 <strong>TypeORMModule</strong> 导入到 <strong>AppModule</strong> 中</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Module</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@nestjs/common&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">TypeOrmModule</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@nestjs/typeorm&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">User</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./users/user.entity&#x27;</span>;<br><br><span class="hljs-meta">@Module</span>(&#123;<br>  <span class="hljs-attr">imports</span>: [<br>    <span class="hljs-title class_">TypeOrmModule</span>.<span class="hljs-title function_">forRoot</span>(&#123;<br>      <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;mysql&#x27;</span>,<br>      <span class="hljs-attr">host</span>: <span class="hljs-string">&#x27;localhost&#x27;</span>,<br>      <span class="hljs-attr">port</span>: <span class="hljs-number">3306</span>,<br>      <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;root&#x27;</span>,<br>      <span class="hljs-attr">password</span>: <span class="hljs-string">&#x27;root&#x27;</span>,<br>      <span class="hljs-attr">database</span>: <span class="hljs-string">&#x27;db_nest&#x27;</span>,<br>      <span class="hljs-attr">entities</span>: [<span class="hljs-title class_">User</span>],<br>      <span class="hljs-attr">synchronize</span>: <span class="hljs-literal">true</span>,<br>    &#125;),<br>  ],<br>&#125;)<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppModule</span> &#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="实体表如何引入"><a href="#实体表如何引入" class="headerlink" title="实体表如何引入"></a>实体表如何引入</h3><p>但是我们发现一个问题，如果表很多怎么办，总不能全部import进来之后写进去</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">User</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./users/user.entity&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Todo</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./todo/todo.entity&#x27;</span>;<br><span class="hljs-comment">// 其他entity实体</span><br><span class="hljs-meta">@Module</span>(&#123;<br>  <span class="hljs-attr">imports</span>: [<br>    <span class="hljs-title class_">TypeOrmModule</span>.<span class="hljs-title function_">forRoot</span>(&#123;<br>      <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;mysql&#x27;</span>,<br>      <span class="hljs-attr">host</span>: <span class="hljs-string">&#x27;localhost&#x27;</span>,<br>      <span class="hljs-attr">port</span>: <span class="hljs-number">3306</span>,<br>      <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;root&#x27;</span>,<br>      <span class="hljs-attr">password</span>: <span class="hljs-string">&#x27;root&#x27;</span>,<br>      <span class="hljs-attr">database</span>: <span class="hljs-string">&#x27;db_nest&#x27;</span>,<br>      <span class="hljs-attr">entities</span>: [<span class="hljs-title class_">User</span>, <span class="hljs-title class_">Todo</span>, <span class="hljs-comment">// 其他实体],</span><br>      <span class="hljs-attr">synchronize</span>: <span class="hljs-literal">true</span>,<br>    &#125;),<br>  ],<br>&#125;)<br><br><span class="hljs-comment">// 我们也可以自动加载实体</span><br><br><span class="hljs-comment">// 方式一：添加 autoLoadEntities 为 true</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Module</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@nestjs/common&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">TypeOrmModule</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@nestjs/typeorm&#x27;</span>;<br><br><span class="hljs-meta">@Module</span>(&#123;<br>  <span class="hljs-attr">imports</span>: [<br>    <span class="hljs-title class_">TypeOrmModule</span>.<span class="hljs-title function_">forRoot</span>(&#123;<br>      ...<br>      <span class="hljs-attr">autoLoadEntities</span>: <span class="hljs-literal">true</span>,<br>    &#125;),<br>  ],<br>&#125;)<br><br><span class="hljs-comment">// 方式二：获取所有项目下的 entity.ts 文件为实体</span><br><span class="hljs-meta">@Module</span>(&#123;<br>  <span class="hljs-attr">imports</span>: [<br>    <span class="hljs-title class_">TypeOrmModule</span>.<span class="hljs-title function_">forRoot</span>(&#123;<br>      ...<br>      <span class="hljs-attr">entities</span>: [__dirname + <span class="hljs-string">&#x27;/**/*.entity&#123;.ts,.js&#125;&#x27;</span>],<br>    &#125;),<br>  ],<br>&#125;)<br></code></pre></td></tr></table></figure><p>上面两种方式都可以成功集成TypeORM</p><h3 id="TypeORM如何定义表结构"><a href="#TypeORM如何定义表结构" class="headerlink" title="TypeORM如何定义表结构"></a>TypeORM如何定义表结构</h3><p>我们主要了解一下TypeORM的主要内容：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Entity</span>, <span class="hljs-title class_">Column</span>, <span class="hljs-title class_">PrimaryGeneratedColumn</span>, <span class="hljs-title class_">OneToMany</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;typeorm&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Photo</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../photos/photo.entity&#x27;</span>;<br><br><span class="hljs-meta">@Entity</span>()<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>  <span class="hljs-meta">@PrimaryGeneratedColumn</span>()<br>  <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span>;<br><br>  <span class="hljs-meta">@Column</span>()<br>  <span class="hljs-attr">firstName</span>: <span class="hljs-built_in">string</span>;<br><br>  <span class="hljs-meta">@Column</span>()<br>  <span class="hljs-attr">lastName</span>: <span class="hljs-built_in">string</span>;<br><br>  <span class="hljs-meta">@Column</span>(&#123; <span class="hljs-attr">default</span>: <span class="hljs-literal">true</span> &#125;)<br>  <span class="hljs-attr">isActive</span>: <span class="hljs-built_in">boolean</span>;<br><br>  <span class="hljs-meta">@OneToMany</span>(<span class="hljs-function"><span class="hljs-params">type</span> =&gt;</span> <span class="hljs-title class_">Photo</span>, <span class="hljs-function"><span class="hljs-params">photo</span> =&gt;</span> photo.<span class="hljs-property">user</span>)<br>  <span class="hljs-attr">photos</span>: <span class="hljs-title class_">Photo</span>[];<br>&#125;<br></code></pre></td></tr></table></figure><p>这里就定义了一个<strong>users</strong>表，如果你想要自定义表名称，可以在@Entity(‘user’)中添加 <code>user</code>，这样就是加载 user 表。</p><p>主要涉及到的是主键列，普通列，外键列（一对一、一对多、多对一、多对多），这里表示 <code>users</code> 表中的 <code>photo</code> 字段，关联到的是 <code>Photo</code> 实体，也就是 <code>photos</code> 表，如果它没有显示指定，然后是一对多的关系，表示一个用户会有多张照片，关联的字段是 <code>photos</code> 表中的 <code>user</code> 字段</p><p>在column装饰器中有很多有趣的属性，例如字段类型，字段名称，字段长度，是否为空，默认值等等，基本跟数据表的属性差不太多。</p><h3 id="外键绑定的注意点"><a href="#外键绑定的注意点" class="headerlink" title="外键绑定的注意点"></a>外键绑定的注意点</h3><blockquote><p>我们需要注意以下两种情况<br>1：级联删除<br>默认我们在有外键关联的数据表中，不会去主动设置cascade为true、onDelete为CASCADE<br>因为一旦设置过，删除数据时，外键关联到的数据也会被删除</p><p>2：级联查询<br>默认我们在查询数据的时候，有的时候我们并不希望将外键关联的数据给查询出来，所以默认查询单条数据时不会自动加载一对多关联的数据<br>但是当我指定 relations 时，它会去查询关联的数据，只有你加上了 eager为 true 的时候会自动查询 </p></blockquote><p>例如查询用户关联的图片</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> userRepository.<span class="hljs-title function_">findOne</span>(&#123;<br>  <span class="hljs-attr">where</span>: &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">1</span> &#125;,<br>  <span class="hljs-attr">relations</span>: [<span class="hljs-string">&#x27;photos&#x27;</span>],<br>&#125;);<br><br><span class="hljs-comment">// 查询结果是这样的</span><br>&#123;<br>  <span class="hljs-string">&quot;id&quot;</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-string">&quot;photos&quot;</span>: [<br>    &#123; <span class="hljs-string">&quot;id&quot;</span>: <span class="hljs-number">10</span>, <span class="hljs-string">&quot;url&quot;</span>: <span class="hljs-string">&quot;xxx&quot;</span> &#125;,<br>    &#123; <span class="hljs-string">&quot;id&quot;</span>: <span class="hljs-number">11</span>, <span class="hljs-string">&quot;url&quot;</span>: <span class="hljs-string">&quot;yyy&quot;</span> &#125;<br>  ]<br>&#125;<br><br><span class="hljs-comment">// 如果不带 relations 的时候，查询结果是这样的</span><br>&#123;<br>  <span class="hljs-string">&quot;id&quot;</span>: <span class="hljs-number">1</span><br>  <span class="hljs-comment">// 没有 photos</span><br>&#125;<br></code></pre></td></tr></table></figure><p>TypeORM还有一种方式可以支持你查询关联数据</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Entity</span>()<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>  <span class="hljs-meta">@PrimaryGeneratedColumn</span>()<br>  <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span>;<br><br>  <span class="hljs-meta">@OneToMany</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">Photo</span>, <span class="hljs-function"><span class="hljs-params">photo</span> =&gt;</span> photo.<span class="hljs-property">user</span>)<br>  <span class="hljs-attr">photos</span>: <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">Photo</span>[]&gt;; <span class="hljs-comment">// 注意这里是 Promise</span><br>&#125;<br><br><span class="hljs-comment">// 当我把 photos 设置成了 Promse 然后发起查询</span><br><br><span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> userRepository.<span class="hljs-title function_">findOne</span>(&#123; <span class="hljs-attr">where</span>: &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">1</span> &#125; &#125;);<br><br><span class="hljs-comment">// 此时 user 里并没有真的装载 photos</span><br><span class="hljs-comment">// 但是当你写了以下代码的时候，它会执行以下sql查询语句</span><br><br><span class="hljs-keyword">const</span> photos = <span class="hljs-keyword">await</span> user.<span class="hljs-property">photos</span>;<br><br><span class="hljs-comment">// SELECT * FROM photo WHERE userId = 1;</span><br></code></pre></td></tr></table></figure><p>但是 <strong>lazy loading</strong> 有一个缺点，就是它是单个查询，如果我需要查询一批用户，然后再用循环语句去获取每个用户 <strong>photos</strong> 的时候，你的查询会变成 <strong>N+1</strong> 查询。也就是一次用户数据查询加上n次的用户photos查询，此用法会造成性能问题并且SQL很难优化。</p><p>所以，我还是更加推荐显示写 <strong>relations</strong> ，这样 SQL 才会可控。</p><h3 id="多个数据库如何连接"><a href="#多个数据库如何连接" class="headerlink" title="多个数据库如何连接"></a>多个数据库如何连接</h3><p>通常我们的项目中可能会连接多个数据库，我们可以通过以下方式来创建多个连接</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Module</span>(&#123;<br>  <span class="hljs-attr">imports</span>: [<br>    <span class="hljs-title class_">TypeOrmModule</span>.<span class="hljs-title function_">forRoot</span>(&#123;<br>      ...defaultOptions,<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;default&#x27;</span>,<br>      <span class="hljs-attr">host</span>: <span class="hljs-string">&#x27;user_db_host&#x27;</span>,<br>      <span class="hljs-attr">entities</span>: [<span class="hljs-title class_">User</span>],<br>    &#125;),<br>    <span class="hljs-title class_">TypeOrmModule</span>.<span class="hljs-title function_">forRoot</span>(&#123;<br>      ...defaultOptions,<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;albumsConnection&#x27;</span>,<br>      <span class="hljs-attr">host</span>: <span class="hljs-string">&#x27;album_db_host&#x27;</span>,<br>      <span class="hljs-attr">entities</span>: [<span class="hljs-title class_">Album</span>],<br>    &#125;),<br>  ],<br>&#125;)<br></code></pre></td></tr></table></figure><p>我们发现配置中多了name属性，这是因为如果只有一个连接，你可以不写name，默认就是 <code>default</code>，但是如果有多个连接，我们应该区分名称，这样连接不会被覆盖</p><p>然后我们在使用表的时候，需要告诉 <code>TypeOrmModule.forFeature()</code> 方法和 <code>@InjectRepository()</code> 装饰器应该使用哪个数据源，如果不写，默认是 <code>default</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Module</span>(&#123;<br>  <span class="hljs-attr">imports</span>: [<br>    <span class="hljs-title class_">TypeOrmModule</span>.<span class="hljs-title function_">forFeature</span>([<span class="hljs-title class_">User</span>]), <span class="hljs-comment">// default名称的连接库中找 users 表</span><br>    <span class="hljs-title class_">TypeOrmModule</span>.<span class="hljs-title function_">forFeature</span>([<span class="hljs-title class_">Album</span>], <span class="hljs-string">&#x27;albumsConnection&#x27;</span>), <span class="hljs-comment">// albumsConnection名称的连接库中找 albums 表</span><br>  ],<br>&#125;)<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppModule</span> &#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="如何使用TypeORM来编写业务代码"><a href="#如何使用TypeORM来编写业务代码" class="headerlink" title="如何使用TypeORM来编写业务代码"></a>如何使用TypeORM来编写业务代码</h3><p>在处理完连接后，我们应该这样使用</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Module</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@nestjs/common&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">TypeOrmModule</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@nestjs/typeorm&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">UsersService</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./users.service&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">UsersController</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./users.controller&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">User</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./user.entity&#x27;</span>;<br><br><span class="hljs-meta">@Module</span>(&#123;<br>  <span class="hljs-comment">// 这里引入 users 表</span><br>  <span class="hljs-attr">imports</span>: [<span class="hljs-title class_">TypeOrmModule</span>.<span class="hljs-title function_">forFeature</span>([<span class="hljs-title class_">User</span>])],<br>  <span class="hljs-attr">providers</span>: [<span class="hljs-title class_">UsersService</span>],<br>  <span class="hljs-attr">controllers</span>: [<span class="hljs-title class_">UsersController</span>],<br>&#125;)<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UsersModule</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>然后在userService 中我们可以直接使用表</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Injectable</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@nestjs/common&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">InjectRepository</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@nestjs/typeorm&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Repository</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;typeorm&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">User</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./user.entity&#x27;</span>;<br><br><span class="hljs-meta">@Injectable</span>()<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UsersService</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span><br><span class="hljs-params">    <span class="hljs-comment">// 注入 users 表</span></span><br><span class="hljs-params">    <span class="hljs-meta">@InjectRepository</span>(User)</span><br><span class="hljs-params">    <span class="hljs-keyword">private</span> usersRepository: Repository&lt;User&gt;,</span><br><span class="hljs-params">  </span>) &#123;&#125;<br><br>  <span class="hljs-title function_">findAll</span>(): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">User</span>[]&gt; &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">usersRepository</span>.<span class="hljs-title function_">find</span>();<br>  &#125;<br><br>  <span class="hljs-title function_">findOne</span>(<span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">User</span> | <span class="hljs-literal">null</span>&gt; &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">usersRepository</span>.<span class="hljs-title function_">findOneBy</span>(&#123; id &#125;);<br>  &#125;<br><br>  <span class="hljs-keyword">async</span> <span class="hljs-title function_">remove</span>(<span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt; &#123;<br>    <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">usersRepository</span>.<span class="hljs-title function_">delete</span>(id);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h3><p>当然我们后面还有transaction，异步配置等等，等需要的时候可以阅读文档进行使用或接入</p><h2 id="nestjs接入验证"><a href="#nestjs接入验证" class="headerlink" title="nestjs接入验证"></a>nestjs接入验证</h2><h3 id="validation的集成"><a href="#validation的集成" class="headerlink" title="validation的集成"></a>validation的集成</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm i --save class-validator class-transformer<br></code></pre></td></tr></table></figure><p>一般参数的验证都是可以放到全局的，有两种方式可以全局应用</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 方式一：在根模块的providers中注册</span><br>&#123;<br>  <span class="hljs-attr">provide</span>: <span class="hljs-variable constant_">APP_PIPE</span>,<br>  <span class="hljs-attr">useFactory</span>: <span class="hljs-function">() =&gt;</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ValidationPipe</span>(&#123;<br>  <span class="hljs-attr">transform</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">whitelist</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">forbidNonWhitelisted</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">disableErrorMessages</span>: <span class="hljs-literal">false</span>,<br>&#125;);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 方式二：在 main.ts 主文件中注册</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">bootstrap</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> app = <span class="hljs-keyword">await</span> <span class="hljs-title class_">NestFactory</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">AppModule</span>);<br>  app.<span class="hljs-title function_">useGlobalPipes</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ValidationPipe</span>(&#123; <span class="hljs-attr">transform</span>: <span class="hljs-literal">true</span> &#125;));<br>  <span class="hljs-keyword">await</span> app.<span class="hljs-title function_">listen</span>(process.<span class="hljs-property">env</span>.<span class="hljs-property">PORT</span> ?? <span class="hljs-number">3000</span>);<br>&#125;<br><span class="hljs-title function_">bootstrap</span>();<br></code></pre></td></tr></table></figure><p>我们发现 <code>ValidationPipe</code> 允许我们传递一些参数</p><ul><li>enableDebugMessages（boolean）：在出现问题时向控制台打印额外的警告信息</li><li>skipUndefinedProperties（boolean）：跳过验证对象中所有未定义属性的验证</li><li>whitelist（boolean）：删除非白名单属性</li><li>disableErrorMessages（boolean）：不返回错误信息给客户端</li><li>还有其他的属性可以控制验证的行为</li></ul><h3 id="validation的使用"><a href="#validation的使用" class="headerlink" title="validation的使用"></a>validation的使用</h3><p>一般验证都是 <code>dto</code> 文件</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Post</span>()<br><span class="hljs-title function_">create</span>(<span class="hljs-params"><span class="hljs-meta">@Body</span>() createUserDto: CreateUserDto</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;This action adds a new user&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>dto</code> 文件应该是这样的</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123;<br>  <span class="hljs-title class_">IsEnum</span>, <span class="hljs-comment">// 枚举</span><br>  <span class="hljs-title class_">IsNotEmpty</span>, <span class="hljs-comment">// 不为空</span><br>  <span class="hljs-title class_">IsNumber</span>, <span class="hljs-comment">// 数值</span><br>  <span class="hljs-title class_">IsOptional</span>, <span class="hljs-comment">// 可选</span><br>  <span class="hljs-title class_">IsString</span>, <span class="hljs-comment">// 字符串</span><br>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;class-validator&#x27;</span>;<br><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Status</span> &#123;<br>  <span class="hljs-variable constant_">OK</span> = <span class="hljs-number">1</span>,<br>  <span class="hljs-variable constant_">NOTOK</span> = <span class="hljs-number">2</span>,<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CreateUserDto</span> &#123;<br>  <span class="hljs-meta">@IsString</span>()<br>  <span class="hljs-meta">@IsNotEmpty</span>()<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br> <br>  <span class="hljs-meta">@IsOptional</span>()<br>  <span class="hljs-meta">@IsNumber</span>()<br>  <span class="hljs-meta">@IsEnum</span>(<span class="hljs-title class_">Status</span>) <span class="hljs-comment">// 这个告诉用户status是可选的，如果传了，必须是1或2</span><br>  status?: <span class="hljs-title class_">Status</span>; <span class="hljs-comment">// 1=ok, 2=not ok</span><br>&#125;<br></code></pre></td></tr></table></figure><p>然后我们在请求创建新用户的时候，就会走 <code>dto</code> 的验证</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 传递参数如下</span><br>&#123;<br><span class="hljs-attr">status</span>: <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-comment">// 提示 name 必传</span><br><br>&#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Justin&quot;</span>,<br>  <span class="hljs-attr">status</span>: <span class="hljs-number">3</span><br>&#125;<br><br><span class="hljs-comment">// 提示 status 必须是 1 或 2</span><br></code></pre></td></tr></table></figure><h3 id="其他用法"><a href="#其他用法" class="headerlink" title="其他用法"></a>其他用法</h3><p>当然你还可以针对 <code>CreateUserDto</code> 进行显示的转换，例如比如你还有一个字符串的数值，就可以在service中这么写来进行转换</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Get</span>(<span class="hljs-string">&#x27;:id&#x27;</span>)<br><span class="hljs-title function_">findOne</span>(<span class="hljs-params"></span><br><span class="hljs-params">  <span class="hljs-meta">@Param</span>(<span class="hljs-string">&#x27;id&#x27;</span>, ParseIntPipe) id: <span class="hljs-built_in">number</span>,</span><br><span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> id === <span class="hljs-string">&#x27;number&#x27;</span>); <span class="hljs-comment">// true</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;This action returns a user&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然你可以创建一个新的用户，用的是 <code>CreateUserDto</code>，那么你也可以更新用户信息，用的就是 <code>UpdateUserDto</code>，我们发现，更新和创建的区别就是是否需要传递主键，并且更新的话，每个字段其实都是可选的，按照restful的风格，应该是传递两个参数，第一个是需要更新的数据的主键id，然后就是需要更新的数据</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UpdateUserDto</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">PartialType</span>(<span class="hljs-title class_">CreateUserDto</span>) &#123;&#125;<br></code></pre></td></tr></table></figure><p>这样我们相当于直接复用了 <code>CreateUserDto</code> 的字段，并将每个字段变成可选类型</p><h2 id="nestjs接入MONGO"><a href="#nestjs接入MONGO" class="headerlink" title="nestjs接入MONGO"></a>nestjs接入MONGO</h2><h3 id="mongoose-集成"><a href="#mongoose-集成" class="headerlink" title="mongoose 集成"></a>mongoose 集成</h3><p>安装所需的依赖项</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm i @nestjs/mongoose mongoose<br></code></pre></td></tr></table></figure><p>然后在根模块导入进行 <code>mongoose</code> 的使用</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Module</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@nestjs/common&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">MongooseModule</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@nestjs/mongoose&#x27;</span>;<br><br><span class="hljs-meta">@Module</span>(&#123;<br>  <span class="hljs-attr">imports</span>: [<span class="hljs-title class_">MongooseModule</span>.<span class="hljs-title function_">forRoot</span>(<span class="hljs-string">&#x27;mongodb://localhost/nest&#x27;</span>)],<br>&#125;)<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppModule</span> &#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="如何定义mongo-collection"><a href="#如何定义mongo-collection" class="headerlink" title="如何定义mongo collection"></a>如何定义mongo collection</h3><p>使用 Mongoose，一切都是 Schema，每个 Schema 都映射到一个 MongoDB Collection</p><p>例如我们的用户表，其实可以放到 <code>mongo</code> 中</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Prop</span>, <span class="hljs-title class_">Schema</span>, <span class="hljs-title class_">SchemaFactory</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@nestjs/mongoose&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">HydratedDocument</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;mongoose&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> <span class="hljs-title class_">UserDocument</span> = <span class="hljs-title class_">HydratedDocument</span>&lt;<span class="hljs-title class_">User</span>&gt;;<br><br><span class="hljs-meta">@Schema</span>(&#123;<br>  <span class="hljs-attr">timestamps</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 默认添加返回创建时间和更新时间</span><br>  <span class="hljs-attr">collection</span>: <span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-comment">// collection 名称，如果不主动设置，那么就跟mysql entity一样，就是对应的 users collection</span><br>  <span class="hljs-attr">toJSON</span>: &#123; <span class="hljs-comment">// 设置之后，exec查询结果后，可以通过调用 toJSON 方法进行转换调用</span><br>    <span class="hljs-attr">virtuals</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">versionKey</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">transform</span>: <span class="hljs-function">(<span class="hljs-params">_, ret: <span class="hljs-built_in">any</span></span>) =&gt;</span> &#123;<br>      ret.<span class="hljs-property">id</span> = ret.<span class="hljs-property">_id</span>.<span class="hljs-title function_">toString</span>();<br>      <span class="hljs-keyword">delete</span> ret.<span class="hljs-property">_id</span>;<br>      <span class="hljs-keyword">return</span> ret;<br>    &#125;,<br>  &#125;,<br>&#125;)<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>  <span class="hljs-meta">@Prop</span>()<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br><br>  <span class="hljs-meta">@Prop</span>()<br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br><br>  <span class="hljs-meta">@Prop</span>()<br>  <span class="hljs-attr">hobby</span>: <span class="hljs-built_in">string</span>;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">UserSchema</span> = <span class="hljs-title class_">SchemaFactory</span>.<span class="hljs-title function_">createForClass</span>(<span class="hljs-title class_">User</span>);<br></code></pre></td></tr></table></figure><p><code>@Prop</code> 装饰器是用来定义文档中的属性的，一些简单的字段类型它可以自动推断，但是一些复杂的需要我们去主动申明</p><p>例如一个数组字符串</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Prop</span>([<span class="hljs-title class_">String</span>])<br><span class="hljs-attr">tags</span>: <span class="hljs-built_in">string</span>[];<br></code></pre></td></tr></table></figure><p><strong>Props</strong> 中还允许你传递一系列的 options 参数</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Prop</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>, <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span> &#125;)<br><span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br></code></pre></td></tr></table></figure><h3 id="如何注册mongoose-collection"><a href="#如何注册mongoose-collection" class="headerlink" title="如何注册mongoose collection"></a>如何注册mongoose collection</h3><p>上面我们定义了一个user collection，那么我们应该怎么将它注册进去呢？</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Module</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@nestjs/common&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">MongooseModule</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@nestjs/mongoose&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">UserController</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./user.controller&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">UserService</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./user.service&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">User</span>, <span class="hljs-title class_">UserSchema</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./schemas/user.schema&#x27;</span>;<br><br><span class="hljs-meta">@Module</span>(&#123;<br>  <span class="hljs-attr">imports</span>: [<span class="hljs-title class_">MongooseModule</span>.<span class="hljs-title function_">forFeature</span>([&#123; <span class="hljs-attr">name</span>: <span class="hljs-title class_">User</span>.<span class="hljs-property">name</span>, <span class="hljs-attr">schema</span>: <span class="hljs-title class_">UserSchema</span> &#125;])],<br>  <span class="hljs-attr">controllers</span>: [<span class="hljs-title class_">UserController</span>],<br>  <span class="hljs-attr">providers</span>: [<span class="hljs-title class_">UserService</span>],<br>&#125;)<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserModule</span> &#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="如何使用mongoose来编写业务代码"><a href="#如何使用mongoose来编写业务代码" class="headerlink" title="如何使用mongoose来编写业务代码"></a>如何使用mongoose来编写业务代码</h3><p>在上面注册了 User Collection 之后，我们可以在service层编写相关的业务代码</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Model</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;mongoose&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Injectable</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@nestjs/common&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">InjectModel</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@nestjs/mongoose&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">User</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./schemas/user.schema&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">CreateUserDto</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./dto/create-user.dto&#x27;</span>;<br><br><span class="hljs-meta">@Injectable</span>()<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-meta">@InjectModel</span>(User.name) <span class="hljs-keyword">private</span> userModel: Model&lt;User&gt;</span>) &#123;&#125;<br><br>  <span class="hljs-keyword">async</span> <span class="hljs-title function_">create</span>(<span class="hljs-attr">createUserDto</span>: <span class="hljs-title class_">CreateUserDto</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">User</span>&gt; &#123;<br>    <span class="hljs-keyword">const</span> cteatedUser = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">userModel</span>.<span class="hljs-title function_">create</span>(createUserDto);<br>    <span class="hljs-keyword">return</span> cteatedUser.<span class="hljs-title function_">toJSON</span>();<br>  &#125;<br><br>  <span class="hljs-keyword">async</span> <span class="hljs-title function_">findAll</span>(): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">User</span>[]&gt; &#123;<br>    <span class="hljs-keyword">const</span> docs = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">userModel</span>.<span class="hljs-title function_">find</span>().<span class="hljs-title function_">exec</span>();<br>    <span class="hljs-keyword">return</span> docs.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">d</span>) =&gt;</span> d.<span class="hljs-title function_">toJSON</span>());<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!warning] 注意<br>我们通过 Model 查询返回的其实是 mongoose 的 document<br>所以我们最好是通过 toJSON 对 document 数据进行一个处理返回</p></blockquote><h3 id="如何连接多个数据库"><a href="#如何连接多个数据库" class="headerlink" title="如何连接多个数据库"></a>如何连接多个数据库</h3><p>我们通常会连接多个mongoose库</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Module</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@nestjs/common&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">MongooseModule</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@nestjs/mongoose&#x27;</span>;<br><br><span class="hljs-meta">@Module</span>(&#123;<br>  <span class="hljs-attr">imports</span>: [<br>    <span class="hljs-title class_">MongooseModule</span>.<span class="hljs-title function_">forRoot</span>(<span class="hljs-string">&#x27;mongodb://localhost/test&#x27;</span>, &#123;<br>      <span class="hljs-attr">connectionName</span>: <span class="hljs-string">&#x27;test&#x27;</span>, <span class="hljs-comment">// 通过 connectionName 来区分，否则会覆盖</span><br>    &#125;),<br>    <span class="hljs-title class_">MongooseModule</span>.<span class="hljs-title function_">forRoot</span>(<span class="hljs-string">&#x27;mongodb://localhost/users&#x27;</span>, &#123;<br>      <span class="hljs-attr">connectionName</span>: <span class="hljs-string">&#x27;users&#x27;</span>,<br>    &#125;),<br>  ],<br>&#125;)<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppModule</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>然后当我们主动设置了 <code>connectionName</code> 后，我们在注册的时候，应该带上 <code>connectionName</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Module</span>(&#123;<br>  <span class="hljs-attr">imports</span>: [<br>    <span class="hljs-title class_">MongooseModule</span>.<span class="hljs-title function_">forFeature</span>([&#123; <span class="hljs-attr">name</span>: <span class="hljs-title class_">User</span>.<span class="hljs-property">name</span>, <span class="hljs-attr">schema</span>: <span class="hljs-title class_">UserSchema</span> &#125;], <span class="hljs-string">&#x27;users&#x27;</span>),<br>  ],<br>&#125;)<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserModule</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>然后在service中这样使用</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Injectable</span>()<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-meta">@InjectModel</span>(User.name, <span class="hljs-string">&#x27;users&#x27;</span>) <span class="hljs-keyword">private</span> userModel: Model&lt;User&gt;</span>) &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="其他用法-1"><a href="#其他用法-1" class="headerlink" title="其他用法"></a>其他用法</h3><p>当然在mongoose中还有事务，插件，子文档等功能，等实际用到了可以查看文档进行补充学习</p>]]></content>
    
    
    
    <tags>
      
      <tag>nestjs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>上手nestjs</title>
    <link href="/2025/09/12/%E4%B8%8A%E6%89%8Bnestjs/"/>
    <url>/2025/09/12/%E4%B8%8A%E6%89%8Bnestjs/</url>
    
    <content type="html"><![CDATA[<h2 id="如何安装nestjs"><a href="#如何安装nestjs" class="headerlink" title="如何安装nestjs"></a>如何安装nestjs</h2><p>因为后续会选择nestjs创建不同的应用，所以推荐安装nestjs的官方生成工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm i -g @nestjs/cli<br><br>nest new project-name<br><br>nest new project-name --strict<br></code></pre></td></tr></table></figure><p>因为nestjs完全支持使用typescript构建，所以传递 <strong>–strict</strong> 可以使项目有更加严格的功能集</p><p>创建提示如下：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs gradle">PS C:\nestjs&gt; nest <span class="hljs-keyword">new</span> <span class="hljs-keyword">project</span>-name --strict<br>✨  We will scaffold your app in a few seconds..<br><br>✔ Which <span class="hljs-keyword">package</span> manager would you ❤️  to use? npm<br>CREATE <span class="hljs-keyword">project</span>-name/.prettierrc (<span class="hljs-number">54</span> bytes)<br>CREATE <span class="hljs-keyword">project</span>-name/eslint.config.mjs (<span class="hljs-number">869</span> bytes)<br>CREATE <span class="hljs-keyword">project</span>-name/nest-cli.json (<span class="hljs-number">179</span> bytes)<br>CREATE <span class="hljs-keyword">project</span>-name/<span class="hljs-keyword">package</span>.json (<span class="hljs-number">2054</span> bytes)<br>CREATE <span class="hljs-keyword">project</span>-name/README.md (<span class="hljs-number">5126</span> bytes)<br>CREATE <span class="hljs-keyword">project</span>-name/tsconfig.build.json (<span class="hljs-number">101</span> bytes)<br>CREATE <span class="hljs-keyword">project</span>-name/tsconfig.json (<span class="hljs-number">699</span> bytes)<br>CREATE <span class="hljs-keyword">project</span>-name<span class="hljs-regexp">/src/</span>app.controller.ts (<span class="hljs-number">286</span> bytes)<br>CREATE <span class="hljs-keyword">project</span>-name<span class="hljs-regexp">/src/</span>app.module.ts (<span class="hljs-number">259</span> bytes)<br>CREATE <span class="hljs-keyword">project</span>-name<span class="hljs-regexp">/src/</span>app.service.ts (<span class="hljs-number">150</span> bytes)<br>CREATE <span class="hljs-keyword">project</span>-name<span class="hljs-regexp">/src/m</span>ain.ts (<span class="hljs-number">236</span> bytes)<br>CREATE <span class="hljs-keyword">project</span>-name<span class="hljs-regexp">/src/</span>app.controller.spec.ts (<span class="hljs-number">639</span> bytes)<br>CREATE <span class="hljs-keyword">project</span>-name<span class="hljs-regexp">/test/</span>jest-e2e.json (<span class="hljs-number">192</span> bytes)<br>CREATE <span class="hljs-keyword">project</span>-name<span class="hljs-regexp">/test/</span>app.e2e-spec.ts (<span class="hljs-number">699</span> bytes)<br><br>▹▹▹▹▹ Installation in progress... ☕<br><br>✔ Installation in progress... ☕<br><br>🚀  Successfully created <span class="hljs-keyword">project</span> <span class="hljs-keyword">project</span>-name<br>👉  Get started with the following commands:<br><br>$ cd <span class="hljs-keyword">project</span>-name<br>$ npm run start<br><br><br>                          Thanks <span class="hljs-keyword">for</span> installing Nest 🙏<br>                 Please consider donating to our open collective<br>                        to help us maintain <span class="hljs-keyword">this</span> <span class="hljs-keyword">package</span>.<br></code></pre></td></tr></table></figure><p>默认此命令是安装好所有的依赖，所以你可以直接进入到project-name目录并直接输入<code>npm run start</code>运行项目</p><p>当终端出现如下命令，即表示项目启动成功</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gradle">PS C:\nestjs\<span class="hljs-keyword">project</span>-name&gt; npm run start<br><br>&gt; <span class="hljs-keyword">project</span>-name@<span class="hljs-number">0.0</span>.<span class="hljs-number">1</span> start<br>&gt; nest start<br><br>[Nest] <span class="hljs-number">20636</span>  - <span class="hljs-number">2025</span><span class="hljs-regexp">/09/</span><span class="hljs-number">13</span> <span class="hljs-number">18</span>:<span class="hljs-number">32</span>:<span class="hljs-number">20</span>     LOG [NestFactory] Starting Nest application...<br>[Nest] <span class="hljs-number">20636</span>  - <span class="hljs-number">2025</span><span class="hljs-regexp">/09/</span><span class="hljs-number">13</span> <span class="hljs-number">18</span>:<span class="hljs-number">32</span>:<span class="hljs-number">20</span>     LOG [InstanceLoader] AppModule <span class="hljs-keyword">dependencies</span> initialized +<span class="hljs-number">9</span>ms<br>[Nest] <span class="hljs-number">20636</span>  - <span class="hljs-number">2025</span><span class="hljs-regexp">/09/</span><span class="hljs-number">13</span> <span class="hljs-number">18</span>:<span class="hljs-number">32</span>:<span class="hljs-number">20</span>     LOG [RoutesResolver] AppController &#123;/&#125;: +<span class="hljs-number">4</span>ms<br>[Nest] <span class="hljs-number">20636</span>  - <span class="hljs-number">2025</span><span class="hljs-regexp">/09/</span><span class="hljs-number">13</span> <span class="hljs-number">18</span>:<span class="hljs-number">32</span>:<span class="hljs-number">20</span>     LOG [RouterExplorer] Mapped &#123;/, GET&#125; route +<span class="hljs-number">3</span>ms<br>[Nest] <span class="hljs-number">20636</span>  - <span class="hljs-number">2025</span><span class="hljs-regexp">/09/</span><span class="hljs-number">13</span> <span class="hljs-number">18</span>:<span class="hljs-number">32</span>:<span class="hljs-number">20</span>     LOG [NestApplication] Nest application successfully started +<span class="hljs-number">2</span>ms<br></code></pre></td></tr></table></figure><p>表示nest正在启动nest应用，然后初始化了AppModule，初始化了一个Appcontroller，路由为 &#x2F;，然后 &#x2F; 下有一个 GET 方法，最终nest应用成功启动，这意味着，我们可以在127.0.0.1:3000&#x2F; 直接发送一个GET请求，返回了 “Hello World!”</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs 1c">目录结构如下：<br>src<br> <span class="hljs-string">|</span><br> —— app.controller.spec.ts （controller单元测试）<br> <span class="hljs-string">|</span><br> —— app.controller.ts （controller文件）<br> <span class="hljs-string">|</span><br> —— app.module.ts （应用的根模块文件）<br> <span class="hljs-string">|</span><br> —— app.service.ts （具有单一方法的基本服务）<br> <span class="hljs-string">|</span><br> —— main.ts （应用的入口文件）<br><br></code></pre></td></tr></table></figure><h2 id="如何编写nestjs代码"><a href="#如何编写nestjs代码" class="headerlink" title="如何编写nestjs代码"></a>如何编写nestjs代码</h2><p>首先我们通过<code>npm run start:dev</code>可以运行服务并监视文件中的更改</p><p>这样当我们编写nestjs代码的时候，保存文件后，nestjs将会重新编译，提升开发效率</p><p>nestjs推荐安装 <code>eslint</code> 和 <code>prettier</code> 两个包来统一开发的 lint 和 format</p><h2 id="如何debug代码"><a href="#如何debug代码" class="headerlink" title="如何debug代码"></a>如何debug代码</h2><h3 id="方式一：vscode断点调试"><a href="#方式一：vscode断点调试" class="headerlink" title="方式一：vscode断点调试"></a>方式一：vscode断点调试</h3><p>这里以vscode为例，通常用来开发ts相关的项目</p><p>我们来到运行和调试一栏，主动添加配置，选择 nodejs:通过npm启动</p><p>然后在configurations中就会出现以下配置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JSON"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Launch via NPM&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;request&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;launch&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;runtimeArgs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br><span class="hljs-string">&quot;run-script&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-string">&quot;debug&quot;</span><br>  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;runtimeExecutable&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;npm&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;skipFiles&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br><span class="hljs-string">&quot;&lt;node_internals&gt;/**&quot;</span><br>  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;node&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>此时我们可以修改配置：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JSON"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Launch nestjs&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;request&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;launch&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;runtimeArgs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br><span class="hljs-string">&quot;run&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-string">&quot;start:dev&quot;</span><br>  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;runtimeExecutable&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;npm&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;skipFiles&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br><span class="hljs-string">&quot;&lt;node_internals&gt;/**&quot;</span><br>  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;node&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>此时我们即可通过点击 <code>debug nestjs</code> 左侧的绿色执行按钮启动项目并支持断点调试</p><h3 id="方式二：官方的devtools"><a href="#方式二：官方的devtools" class="headerlink" title="方式二：官方的devtools"></a>方式二：官方的devtools</h3><p>需要付费</p><p>主要是查看模块间的依赖关系以及是否有循环依赖</p><h2 id="了解nestjs的基础概念"><a href="#了解nestjs的基础概念" class="headerlink" title="了解nestjs的基础概念"></a>了解nestjs的基础概念</h2><h3 id="Controllers"><a href="#Controllers" class="headerlink" title="Controllers"></a>Controllers</h3><p>控制器：主要负责处理传入的请求并将响应发送回客户端</p><p>你可以理解为路由的入口，通过不同的模块申明不同的入口，例如user模块，就会有以下restful资源</p><ul><li>【获取所有用户信息】GET &#x2F;user</li><li>【获取单个用户信息】GET &#x2F;user&#x2F;:id</li><li>【新增某个用户信息】POST &#x2F;user&#x2F;:id</li><li>【更新某个用户信息】PATCH &#x2F;user&#x2F;:id</li><li>【删除某个用户信息】DELETE &#x2F;user&#x2F;:id</li></ul><p>在此资源之上，你可以通过装饰器来申明通过什么路径来调用、获取请求参数、重定向、错误处理等等</p><h3 id="providers"><a href="#providers" class="headerlink" title="providers"></a>providers</h3><p>提供程序：nestjs的核心概念，很多nestjs的基础类都是被看作是提供程序，例如 services, repositories, factories, helpers。关键的思想是依赖注入（DI）</p><ol><li>provider不是手动new出来的，而是由nest的 IOC 容器来负责provider的实例化以及生命周期的管理</li><li>每个provider只需要负责完成它自己的功能，控制器只负责路由，逻辑复用和扩展交给provider</li></ol><table><thead><tr><th>配置方式</th><th>示例</th><th>使用场景</th><th>设计理念</th><th>总结</th></tr></thead><tbody><tr><td>useClass</td><td><code>[ &#123; provide: Token, useClass: Logger &#125; ]</code></td><td>用某个类作为实现，常用于替换具体实现<br>开发环境用consoleLogger，<br>生产用fileLogger</td><td>面向接口编程。只要 token 一致，背后实现可随时切换。</td><td>面向抽象，随时换实现</td></tr><tr><td>useValue</td><td><code>[ &#123; provide: Token, useValue: &#123; db: &#39;mysql&#39;, port: 3306 &#125; &#125; ]</code></td><td>注入常量、配置项、工具函数等</td><td>值即是服务，直接把一个对象或函数注册到 IoC 容器，避免硬编码。</td><td>配置即依赖，简单直接</td></tr><tr><td>useFactory</td><td><code>[ &#123; provide: Token, useFactory: (config: ConfigService) =&gt; new DB(config.dbUrl), inject: [ConfigService] &#125; ]</code></td><td>构造逻辑复杂，依赖其他 provider 的场景。</td><td>工厂模式 + DI。容器只管执行工厂函数，返回什么就注入什么。</td><td>动态构造，灵活注入</td></tr><tr><td>useExisting</td><td><code>[ &#123; provide: Token, useExisting: ConsoleLogger &#125; ]</code></td><td>给已有 provider 起别名。  <br>例：AppLoggerToken 与Token 指向同一实例。</td><td>“指针”绑定。多个 token 引用同一 provider，避免重复实例化。</td><td>别名绑定，复用实例</td></tr></tbody></table><h3 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h3><p>modules：提供 Nest 用于有效组织和管理应用程序结构的元数据<br>providers：Nest 注入器将实例化的提供程序，这些程序至少可以在本模块中共享<br>controllers：本模块中定义的、需要实例化的控制器集合<br>imports：本模块所需的提供程序的模块列表（从其他模块export之后再在本模块import）<br>exports：这些提供程序由本模块提供，并应在导入本模块的其他模块中可用。您可以使用提供程序本身，也可以只使用其标记（提供值）</p><h3 id="Middleware"><a href="#Middleware" class="headerlink" title="Middleware"></a>Middleware</h3><p>中间件是在路由处理程序之前调用的函数，中间件函数可以访问请求和响应对象，以及应用程序请求-响应周期中的 <code>next()</code> 中间件函数</p><p>几乎等同于express的中间件</p><h3 id="Exception-filters"><a href="#Exception-filters" class="headerlink" title="Exception filters"></a>Exception filters</h3><p>Exception filters：负责处理应用程序中所有未处理的异常<br>通常用来处理HTTP标准异常、自定义异常、业务异常以及未捕捉到的异常</p><h3 id="Pipes"><a href="#Pipes" class="headerlink" title="Pipes"></a>Pipes</h3><p>pipes的作用</p><ol><li>转换：将输入数据转换为所需的形式（例如，从字符串转换为整数）</li><li>验证：评估输入数据，如果有效，只需将其原封不动地传递;否则，抛出异常</li></ol><h3 id="Guards"><a href="#Guards" class="headerlink" title="Guards"></a>Guards</h3><p>guards：守卫是一个用 <code>@Injectable()</code> 装饰器注释的类，它实现了 <code>CanActivate</code> 接口。</p><p>作用：只有一个责任。它们确定给定请求是否由路由处理程序处理，具体取决于运行时存在的某些条件（如权限、角色、ACL 等）。这通常称为授权。</p><h3 id="Interceptors"><a href="#Interceptors" class="headerlink" title="Interceptors"></a>Interceptors</h3><p>Interceptors：拦截器是一个用 <code>@Injectable()</code> 装饰器注释的类，实现了 <code>NestInterceptor</code> 接口。</p><p>功能：</p><ol><li>在方法执行之前&#x2F;之后绑定额外的逻辑</li><li>转换从函数返回的结果</li><li>转换从函数抛出的异常</li><li>扩展基本函数行为</li><li>根据特定条件完全覆盖函数（例如，用于缓存目的）</li></ol><h2 id="了解nestjs核心模块的执行顺序"><a href="#了解nestjs核心模块的执行顺序" class="headerlink" title="了解nestjs核心模块的执行顺序"></a>了解nestjs核心模块的执行顺序</h2><p>【nest应用启动时初始化】</p><pre><code class=" mermaid">sequenceDiagram    participant AppModule    participant NestFactory    participant IoCContainer as IoC 容器    participant Provider    participant Controller    NestFactory-&gt;&gt;AppModule: 读取根模块    AppModule-&gt;&gt;NestFactory: 返回 imports/controllers/providers    NestFactory-&gt;&gt;IoCContainer: 注册 Providers    IoCContainer-&gt;&gt;Provider: 实例化依赖 (构建依赖树)    NestFactory-&gt;&gt;Controller: 注册 Controllers &amp; 路由    Note over NestFactory,Controller: 应用初始化完成</code></pre><p>【请求生命周期】</p><pre><code class=" mermaid">sequenceDiagram    participant Client    participant Middleware    participant Guard    participant Interceptor as Interceptor(before)    participant Pipe    participant Controller    participant Service    participant InterceptorAfter as Interceptor(after)    participant ExceptionFilter    participant Response    Client-&gt;&gt;Middleware: 进入应用    Middleware-&gt;&gt;Guard: 继续    Guard-&gt;&gt;Interceptor: canActivate 成功    Interceptor-&gt;&gt;Pipe: before handler    Pipe-&gt;&gt;Controller: 参数验证 &amp; 转换    Controller-&gt;&gt;Service: 调用业务逻辑    Service--&gt;&gt;Controller: 返回数据    Controller-&gt;&gt;InterceptorAfter: 结果返回    InterceptorAfter-&gt;&gt;Response: 加工结果后响应    Note over Guard,Response: 如果任意阶段抛错 → ExceptionFilter 捕获</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>nestjs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈CJS和ESM</title>
    <link href="/2025/09/12/hello-world/"/>
    <url>/2025/09/12/hello-world/</url>
    
    <content type="html"><![CDATA[<h3 id="JavaScript的发展史"><a href="#JavaScript的发展史" class="headerlink" title="JavaScript的发展史"></a>JavaScript的发展史</h3><h4 id="JavaScript的发展壮大"><a href="#JavaScript的发展壮大" class="headerlink" title="JavaScript的发展壮大"></a>JavaScript的发展壮大</h4><p>在JavaScript诞生之初只是作为一个脚本语言来使用，主要是做一些简单的表单校验等，因为代码量不多，所以是直接跟html写在一个文件里面，并且用script标签包裹</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html">// index.html<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;shiyuq&#x27;</span></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> age = <span class="hljs-number">18</span></span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>但是随着业务越来越复杂，尤其在ajax出现后代码量飞速增长，开发者们纷纷将JavaScript代码写到单独的js文件中，与html文件解耦，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// index.html</span><br>&lt;script src=<span class="hljs-string">&#x27;./index.js&#x27;</span>&gt;&lt;/script&gt;<br><br><span class="hljs-comment">// index.js</span><br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;shiyuq&#x27;</span><br><span class="hljs-keyword">var</span> age = <span class="hljs-number">18</span><br></code></pre></td></tr></table></figure><p>再后来，多个开发者都将自己的js文件引入到一个html文件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// index.html</span><br>&lt;script src=<span class="hljs-string">&#x27;./index.js&#x27;</span>&gt;&lt;/script&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#x27;./index-shiyuq1.js&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#x27;./index-shiyuq2.js&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br><span class="hljs-comment">// index.js</span><br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;shiyuq&#x27;</span><br><span class="hljs-keyword">var</span> age = <span class="hljs-number">18</span><br><br><span class="hljs-comment">// index-shiyuq1.js</span><br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;faker&#x27;</span><br><span class="hljs-keyword">var</span> age = <span class="hljs-number">28</span><br><br><span class="hljs-comment">// index-shiyuq2.js</span><br><span class="hljs-keyword">var</span> <span class="hljs-title function_">name</span> = (<span class="hljs-params">name</span>) =&gt; &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`hello <span class="hljs-subst">$&#123;name&#125;</span>`</span><br>&#125;<br><span class="hljs-keyword">var</span> <span class="hljs-title function_">age</span> = (<span class="hljs-params">age</span>) =&gt; &#123;<br>    <span class="hljs-keyword">return</span> age + <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure><p>不难发现，问题已经稍有眉头了，此时用哪个文件中的变量完全就取决于谁引用在最下面（在调用它之前），如果在不同文件中变量的类型还不一致，就会导致程序直接崩溃，这种从某种程度上来讲也属于<strong>全局变量污染</strong>，开发者的噩梦就此来临</p><h4 id="模块化的出现"><a href="#模块化的出现" class="headerlink" title="模块化的出现"></a>模块化的出现</h4><p>为了解决全局变量污染的问题，开发者开始使用命名空间的方法，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// index.html</span><br>&lt;script src=<span class="hljs-string">&#x27;./index.js&#x27;</span>&gt;&lt;/script&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#x27;./index-shiyuq1.js&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#x27;./index-shiyuq2.js&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br><span class="hljs-comment">// index.js</span><br>app.<span class="hljs-property">module</span> = &#123;&#125;<br>app.<span class="hljs-property">module</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;shiyuq&#x27;</span><br>app.<span class="hljs-property">module</span>.<span class="hljs-property">age</span> = <span class="hljs-number">18</span><br><br><span class="hljs-comment">// index-shiyuq1.js</span><br>app.<span class="hljs-property">moduleA</span> = &#123;&#125;<br>app.<span class="hljs-property">moduleA</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;faker&#x27;</span><br>app.<span class="hljs-property">moduleA</span>.<span class="hljs-property">age</span> = <span class="hljs-number">28</span><br><br><span class="hljs-comment">// index-shiyuq2.js</span><br>app.<span class="hljs-property">moduleB</span> = &#123;&#125;<br>app.<span class="hljs-property">moduleB</span>.<span class="hljs-property">name</span> = <span class="hljs-function">(<span class="hljs-params">name</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`hello <span class="hljs-subst">$&#123;name&#125;</span>`</span><br>&#125;<br>app.<span class="hljs-property">moduleB</span>.<span class="hljs-property">age</span> = <span class="hljs-function">(<span class="hljs-params">age</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> age + <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure><p>此时，已经有隐隐约约的模块化的概念了，只不过是用命名空间来实现的。但还是有个隐性问题，<code>index-shiyuq1.js</code>的文件作者可以很方便的通过<code>app.module.name</code>来获取到模块<code>index.js</code>中的name，当然也可以很方便的去修改它，但是修改却让<code>index.js</code>毫不知情。这是不允许发生的！</p><p>接着，聪明的开发者们又想到了JavaScript的函数作用域，振臂一呼，用<strong>闭包</strong>可以解决现在的问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// index.html</span><br>&lt;script src=<span class="hljs-string">&quot;./index.js&quot;</span>&gt;&lt;/script&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./index-shiyuq1.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./index-shiyuq2.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br><span class="hljs-comment">// index.js</span><br>app.<span class="hljs-property">module</span> = (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;shiyuq&#x27;</span><br>    <span class="hljs-keyword">var</span> age = <span class="hljs-number">18</span><br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">getName</span>: <span class="hljs-function">() =&gt;</span> name,<br>        <span class="hljs-attr">getAge</span>: <span class="hljs-function">() =&gt;</span> age<br>    &#125;<br>&#125;)()<br><br><span class="hljs-comment">// index-shiyuq1.js</span><br>app.<span class="hljs-property">moduleA</span> = (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;faker&#x27;</span><br>    <span class="hljs-keyword">var</span> age = <span class="hljs-number">28</span><br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">getName</span>: <span class="hljs-function">() =&gt;</span> name,<br>        <span class="hljs-attr">getAge</span>: <span class="hljs-function">() =&gt;</span> age<br>    &#125;<br>&#125;)()<br><br><span class="hljs-comment">// index-shiyuq2.js</span><br>app.<span class="hljs-property">moduleB</span> = (<span class="hljs-keyword">function</span>(<span class="hljs-params">name, age</span>) &#123;<br>    <span class="hljs-keyword">var</span> name = name<br>    <span class="hljs-keyword">var</span> age = age<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">getName</span>: <span class="hljs-function">() =&gt;</span> name,<br>        <span class="hljs-attr">getAge</span>: <span class="hljs-function">() =&gt;</span> age<br>    &#125;<br>&#125;)(<span class="hljs-string">&#x27;hello shiyuq2&#x27;</span>, <span class="hljs-number">28</span> + <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>现在<code>index-shiyuq2.js</code>可以通过<code>app.moduleA.getName()</code>来获取到模块A中的名字，但是各个模块的名字都保存在各自的函数里面，无法修改，但是由于模块的加载有先后顺序，模块B可以访问模块A，但是模块A却无法访问模块B</p><p>所以模块化，不仅要处理全局变量污染，数据的保护，还要解决模块间的依赖关系</p><h3 id="CommonJS应运而生"><a href="#CommonJS应运而生" class="headerlink" title="CommonJS应运而生"></a>CommonJS应运而生</h3><p>为了解决上面出现的一系列问题，所以需要制定模块化的规范，CommonJS就是新的规范，下面来讲解以下CommonJS大致的作用</p><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>node应用是由模块组成，采用了CommonJS规范，每个文件就是一个模块，有自己的作用域，且在一个文件中定义的变量、函数和类都是私有的，对其他文件不可见</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// index.js</span><br><span class="hljs-keyword">var</span> age = <span class="hljs-number">28</span><br><span class="hljs-keyword">var</span> <span class="hljs-title function_">getAge</span> = (<span class="hljs-params">val</span>) =&gt; val - <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>上面的age和getAge都是当前index.js文件私有的，但是如果你想要在多个文件中分享变量，可以使用<code>global</code>关键字</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">global</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;shiyuq&#x27;</span><br></code></pre></td></tr></table></figure><p>虽然但是，不推荐！</p><p>CommonJS规范规定：每个模块内部有两个变量可以使用，分别是<code>require</code>和<code>module</code></p><p>require：用来加载一些模块</p><p>module：代表的是当前模块，是一个对象且上面保存了当前模块的信息。然后它上面有一个<code>exports</code>属性，保存着当前模块要导出的接口或者变量，使用<code>require</code>加载其他模块获取的值其实就是module上面的exports属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// a.js</span><br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;shiyuq&#x27;</span><br><span class="hljs-keyword">var</span> age = <span class="hljs-number">18</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;shiyuq&#x27;</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>.<span class="hljs-property">age</span> = <span class="hljs-number">18</span><br><br><span class="hljs-comment">// b.js</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;a.js&#x27;</span>) <span class="hljs-comment">// 使用require加载a模块</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-property">name</span>) <span class="hljs-comment">// shiyuq</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-property">age</span>) <span class="hljs-comment">// 18</span><br></code></pre></td></tr></table></figure><h4 id="CommonJS——exports"><a href="#CommonJS——exports" class="headerlink" title="CommonJS——exports"></a>CommonJS——exports</h4><p>为了方便，nodejs在实现CommonJS规范的时候，为每个模块都提供了一个<code>exports</code>的私有变量，指向了<code>module.exports</code>，于是你可以理解为exports和module.exports都指向了一个内存地址，所以你给exports中添加属性的同时，module.exports的数据也会同步变化，相当于在每个模块开始的地方，加入了下面一行代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> <span class="hljs-built_in">exports</span> = <span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span><br></code></pre></td></tr></table></figure><p>所以上面的代码也可以这么写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// a.js</span><br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;shiyuq&#x27;</span><br><span class="hljs-keyword">var</span> age = <span class="hljs-number">18</span><br><span class="hljs-built_in">exports</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;shiyuq&#x27;</span><br><span class="hljs-built_in">exports</span>.<span class="hljs-property">age</span> = <span class="hljs-number">18</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>warning</strong>:</p><p>由于exports是模块内部的私有局部变量，它是指向了module.exports的地址，所以你直接对他赋值是不可取的，这相当于改变了此变量的内存地址！！！</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// a.js</span><br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;shiyuq&#x27;</span><br><span class="hljs-keyword">var</span> age = <span class="hljs-number">18</span><br><span class="hljs-built_in">exports</span> = name <span class="hljs-comment">// 这个是不可以的哦，因为你想要导出的肯定是name和age两个属性，现在会导致你实际并未往module.exports上赋值</span><br></code></pre></td></tr></table></figure><p>请看下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> <span class="hljs-variable language_">module</span> = &#123;<span class="hljs-attr">exports</span>: &#123;&#125;&#125;<br><span class="hljs-keyword">var</span> <span class="hljs-built_in">exports</span> = <span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">exports</span>) <span class="hljs-comment">// &#123;&#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>) <span class="hljs-comment">// &#123;&#125;</span><br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;shiyuq&#x27;</span><br><span class="hljs-keyword">var</span> age = <span class="hljs-number">18</span><br><span class="hljs-built_in">exports</span> = name<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">exports</span>) <span class="hljs-comment">// shiyuq</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>) <span class="hljs-comment">// &#123;&#125;</span><br></code></pre></td></tr></table></figure><p>同样，如果你对module.exports重新赋值，也是需要注意的地方</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;shiyuq&#x27;</span><br><span class="hljs-built_in">exports</span>.<span class="hljs-property">name</span> = name<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>) <span class="hljs-comment">// &#123;name: &#x27;shiyuq&#x27;&#125;</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-string">&#x27;hello shiyuq&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>) <span class="hljs-comment">// &#x27;hello shiyuq&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>建议</strong>：可以只使用一种导出的方式，建议使用module.exports，写在每个模块的结尾</p><h4 id="CommonJS的实现"><a href="#CommonJS的实现" class="headerlink" title="CommonJS的实现"></a>CommonJS的实现</h4><p>我们先了解以下CommonJS的一些模块的特点：</p><blockquote><p>1：所有的代码都运行在模块的作用域，不会污染全局作用域</p><p>2：模块可以多次加载，但只会在第一次加载时运行一次，之后缓存运行结果，以后再次加载，直接读取缓存结果，想要让模块再次运行，需要清除缓存</p><p>3：模块加载的顺序，按照其在代码中出现的顺序</p></blockquote><p>在了解了CommonJS的一些关键规范和特点后，我们不难发现CommonJS的主要使用的技术，离不开三个关键字，就是<code>exports</code>，<code>module</code>和<code>require</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// a.js</span><br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;shiyuq&#x27;</span><br><span class="hljs-keyword">var</span> age = <span class="hljs-number">18</span><br><br><span class="hljs-built_in">exports</span>.<span class="hljs-property">name</span> = name<br><span class="hljs-built_in">exports</span>.<span class="hljs-property">age</span> = age<br><br><span class="hljs-comment">// b.js</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;a.js&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-property">name</span>) <span class="hljs-comment">// shiyuq</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-property">age</span>) <span class="hljs-comment">// 18</span><br><br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;jenny&#x27;</span><br><span class="hljs-keyword">var</span> age = <span class="hljs-number">17</span><br><span class="hljs-built_in">exports</span>.<span class="hljs-property">name</span> = name<br><span class="hljs-built_in">exports</span>.<span class="hljs-property">age</span> = age<br><br><span class="hljs-comment">// c.js</span><br><span class="hljs-keyword">var</span> b = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;b.js&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b.<span class="hljs-property">name</span>) <span class="hljs-comment">// jenny</span><br></code></pre></td></tr></table></figure><p>所以结合第一部分咱们对于Javascript的解析后，不难写出CommonJS的简易实现（使用立即执行函数），将require、exports、module三个参数传入，再把模块代码放入立即执行函数中，模块的导出值放在module.exports中，这样就实现了模块的加载，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(<span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable language_">module</span>, <span class="hljs-built_in">exports</span>, <span class="hljs-built_in">require</span></span>) &#123;<br>    <span class="hljs-comment">// b.js</span><br>    <span class="hljs-keyword">var</span> a = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;a.js&#x27;</span>)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-property">name</span>) <span class="hljs-comment">// shiyuq</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-property">name</span>) <span class="hljs-comment">// 18</span><br>    <br>    <span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;jenny&#x27;</span><br>    <span class="hljs-keyword">var</span> age = <span class="hljs-number">17</span><br>    <span class="hljs-built_in">exports</span>.<span class="hljs-property">name</span> = name<br>    <span class="hljs-built_in">exports</span>.<span class="hljs-property">age</span> = age<br>&#125;)(<span class="hljs-variable language_">module</span>, <span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>, <span class="hljs-built_in">require</span>)<br></code></pre></td></tr></table></figure><p>知道了CommonJS的实现原理后，就很容易可以把规范的项目代码转换成浏览器支持的代码，例如咱们熟知的webpack，咱们以webpack为例，看看使用webpack构建的时候，主要做了哪些工作？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// bundle.js</span><br>(<span class="hljs-keyword">function</span>(<span class="hljs-params">modules</span>) &#123;<br>    <span class="hljs-comment">// 模块管理</span><br>&#125;)(&#123;<br>    <span class="hljs-string">&#x27;a.js&#x27;</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable language_">module</span>, <span class="hljs-built_in">exports</span>, <span class="hljs-built_in">require</span></span>) &#123;<br>        <span class="hljs-comment">// a.js 的文件内容</span><br>    &#125;,<br><span class="hljs-string">&#x27;b.js&#x27;</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable language_">module</span>, <span class="hljs-built_in">exports</span>, <span class="hljs-built_in">require</span></span>) &#123;<br>        <span class="hljs-comment">// b.js 的文件内容</span><br>    &#125;,<br>    <span class="hljs-string">&#x27;c.js&#x27;</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable language_">module</span>, <span class="hljs-built_in">exports</span>, <span class="hljs-built_in">require</span></span>) &#123;<br>        <span class="hljs-comment">// c.js 的文件内容</span><br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>接下来，我们需要按照CommonJS的规范，实现模块管理中的内容，然后，我们知道加载过的模块会被缓存，所以我们需要一个对象来缓存加载过的模块，然后需要一个require函数来加载模块，在加载的时候需要生成一个module，并且module上需要有一个exports属性，用来接收模块导出的内容</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// bundle.js</span><br>(<span class="hljs-keyword">function</span>(<span class="hljs-params">modules</span>) &#123;<br>    <span class="hljs-comment">// 模块管理</span><br>    <span class="hljs-keyword">var</span> cachedModules = &#123;&#125;<br>    <span class="hljs-comment">// 加载模块的方法</span><br>    <span class="hljs-keyword">var</span> <span class="hljs-built_in">require</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">moduleName</span>) &#123;<br>        <span class="hljs-comment">// 如果已经有了缓存，直接返回</span><br>        <span class="hljs-keyword">if</span> (cachedModules[moduleName]) <span class="hljs-keyword">return</span> cachedModules[moduleName].<span class="hljs-property">exports</span><br>        <br>        <span class="hljs-comment">// 如果没有加载，就生成一个module，并且放入到cachedModules中</span><br>        <span class="hljs-keyword">var</span> <span class="hljs-variable language_">module</span> = &#123;<br>            moduleName,<br>            <span class="hljs-attr">exports</span>: &#123;&#125;<br>        &#125;<br>        cachedModules[moduleName] = <span class="hljs-variable language_">module</span><br>        <br>        <span class="hljs-comment">// 执行要加载的模块</span><br>        <span class="hljs-comment">// 这里的call只是把this指向到了当前的module.exports，然后会把所有的模块中导出的内容自动加载到module的exports属性上</span><br>        modules[moduleName].<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>, <span class="hljs-variable language_">module</span>, <span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>, <span class="hljs-built_in">require</span>)<br>        <br>        <span class="hljs-comment">// 最后返回module.exports</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;a.js&#x27;</span>)<br>&#125;)(&#123;<br>    <span class="hljs-string">&#x27;a.js&#x27;</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable language_">module</span>, <span class="hljs-built_in">exports</span>, <span class="hljs-built_in">require</span></span>) &#123;<br>        <span class="hljs-comment">// a.js 的文件内容</span><br>    &#125;,<br><span class="hljs-string">&#x27;b.js&#x27;</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable language_">module</span>, <span class="hljs-built_in">exports</span>, <span class="hljs-built_in">require</span></span>) &#123;<br>        <span class="hljs-comment">// b.js 的文件内容</span><br>    &#125;,<br>    <span class="hljs-string">&#x27;c.js&#x27;</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable language_">module</span>, <span class="hljs-built_in">exports</span>, <span class="hljs-built_in">require</span></span>) &#123;<br>        <span class="hljs-comment">// c.js 的文件内容</span><br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>所以上面基本已经实现了CommonJS的核心规范</p><h4 id="require文件的加载流程"><a href="#require文件的加载流程" class="headerlink" title="require文件的加载流程"></a>require文件的加载流程</h4><p>咱们上面已经讲过了require文件的时候，文件会有缓存，那么咱们一般在开发的时候，会有三种类型，通常是核心模块、文件模块以及第三方模块，那么require在加载的时候，遵循什么规律呢？</p><p>核心模块：像fs、http、path等等，都会被识别为nodejs的核心模块</p><p>文件模块：像是使用<code>./</code>、<code>../</code>作为相对路径的文件模块，<code>/</code>作为绝对路径的文件模块</p><p>第三方模块：非路径形式并且也是非核心模块的模块，被称为第三方模块，比如咱们常用的lodash、moment等等</p><p>其中核心模块的加载速度最快，因为已经被编译成二进制代码；而文件模块由于第一次加载会被缓存，所以第二次加载的时候也会很快；所以咱们需要关注的是第三方模块的加载，加载顺序如下：</p><ul><li>首先是在当前的node_modules目录查找</li><li>如果没有，在父级目录的node_modules中查找，如果没有，继续向上查找</li><li>沿着路径递归，直至根目录下的node_modules</li><li>如果没有，提示模块未找到（module *** not found）</li></ul><p>那既然知道了require是如何引入模块的，那么我们来看下面这个问题：<strong>循环引入</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// a.js</span><br><span class="hljs-keyword">var</span> b = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;b.js&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我是a文件&#x27;</span>)<br><span class="hljs-built_in">exports</span>.<span class="hljs-property">sayHi</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">b</span>())<br>&#125;<br><br><span class="hljs-comment">// b.js</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;a.js&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我是b文件&#x27;</span>)<br><span class="hljs-keyword">var</span> userInfo = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;shiyuq&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">18</span><br>&#125;<br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-function">() =&gt;</span> userInfo<br><br><span class="hljs-comment">// main.js</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;a.js&#x27;</span>)<br><span class="hljs-keyword">var</span> b = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;b.js&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我是入口文件&#x27;</span>)<br></code></pre></td></tr></table></figure><p>接下来大家可以在终端中输入<code>node main.js</code>，运行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">我是b文件<br>我是a文件<br>我是入口文件<br></code></pre></td></tr></table></figure><p>所以从上面的运行结果，不难看出CommonJS在分析模块的加载阶段，采用的是深度优先遍历，执行的顺序是父-&gt;子-&gt;父，但是要注意的是在b.js模块还没有加载完成的时候，此时在b.js模块中是没有a模块的sayHi方法的，因为a模块还没有导出sayHi方法【如果你循环引用了，就会出现这样的问题，这在我们的工作中，已经是令人非常头疼的存在】</p><h3 id="其他模块化方案"><a href="#其他模块化方案" class="headerlink" title="其他模块化方案"></a>其他模块化方案</h3><p>我们学习了CommonJS的模块化规范，知道了它的模块加载机制是同步的，这在服务端是可行的，但是在浏览器端，难免会出现页面假死，阻塞后续代码执行，为了解决这个问题，所以后面又发展了一些其他的模块化规范</p><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>后端</td><td>CommonJS</td><td>Node.js</td></tr><tr><td>前端</td><td>AMD</td><td>RequireJS</td></tr><tr><td></td><td>CMD</td><td>Sea.js</td></tr><tr><td>前后端</td><td>ES6 Modules</td><td>ES6</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>因为本来对于前端没有进行深入的研究，个人看法是一开始出现的RequireJS其实就是为了解决CommonJS规范不能用于浏览器的问题，而AMD就是RequireJS在推广过程中对模块定义规范化的产出；而后面出现的sea.js，是由于有人觉得AMD规范是异步的，不够自然和垂直，所以创造了sea.js，大家可以像nodejs一样书写模块代码，随之而然形成了CMD规范</p><p>CommonJS是服务于服务端的，AMD和CMD是服务于客户端的，但是他们都有一个共同点，就是只有在代码运行后才能确定导出的内容，所以从es6开始，ES6 Module将会取代其他规范，成为两端通用的模块解决方案</p><h3 id="ES6-Module"><a href="#ES6-Module" class="headerlink" title="ES6 Module"></a>ES6 Module</h3><p>从ES6开始，在语言标准的层面，就实现了模块化功能，具体可以看<a href="https://es6.ruanyifeng.com/#docs/module">阮一峰ES6 Module</a></p><p>ES6模块的设计思想是尽可能的静态化，是的编译的时候就能确定模块的依赖关系，输入和输出的变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// CommonJS</span><br><span class="hljs-keyword">const</span> &#123;stat, exists, readFile&#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br><span class="hljs-keyword">const</span> &#123;stat, exists, readFile&#125; = fs<br></code></pre></td></tr></table></figure><p>实际CommonJS是去加载了整个模块，然后生成了一个对象，最后再从该对象上取到我们需要的方法，这种也叫做运行时加载，也就是在程序运行起来的时候才能得到这个对象，而ES6模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// es6</span><br><span class="hljs-keyword">import</span> &#123;stat, exists, readFile&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;fs&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="export和import"><a href="#export和import" class="headerlink" title="export和import"></a>export和import</h4><p>export：规定模块的对外接口</p><p>import：输入其他模块提供的功能</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// a.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;shiyuq&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> age = <span class="hljs-number">20</span><br><br><span class="hljs-comment">// 也可以这么写；推荐使用，因为你可以在模块的结尾很清楚的知道你导出了哪些变量</span><br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;shiyuq&#x27;</span><br><span class="hljs-keyword">var</span> age = <span class="hljs-number">20</span><br><span class="hljs-built_in">exports</span> &#123;<br>    name,<br>    age<br>&#125;<br></code></pre></td></tr></table></figure><p>你还可以重命名</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 输出函数getName</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getName</span> (name) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;hello&#x27;</span> + name<br>&#125;<br><br><span class="hljs-comment">// 你还可以这样</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getAge</span> () &#123;&#125;<br><br><span class="hljs-keyword">export</span> &#123;<br>getAge <span class="hljs-keyword">as</span> getAgeNew<br>&#125;<br></code></pre></td></tr></table></figure><p>但是你需要特别注意，export命令规定必须与模块内部的变量建立一一对应的关系</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 错误</span><br><span class="hljs-keyword">export</span> <span class="hljs-number">1</span><br><span class="hljs-comment">// 错误</span><br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;shiyuq&#x27;</span><br><span class="hljs-keyword">export</span> name<br></code></pre></td></tr></table></figure><p>上面实际导出的都是一个值，没有对应关系</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 建立name和shiyuq的对应关系</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;shiyuq&#x27;</span><br><br><span class="hljs-comment">// 建立name和shiyuq的对应关系</span><br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;shiyuq&#x27;</span><br><span class="hljs-keyword">export</span> &#123;name&#125;<br><br><span class="hljs-comment">// 建立name和shiyuq的对应关系</span><br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;shiyuq&#x27;</span><br><span class="hljs-keyword">export</span> &#123;name <span class="hljs-keyword">as</span> nameNew&#125;<br><br><span class="hljs-comment">// 错误</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>) &#123;&#125;<br><span class="hljs-keyword">export</span> f<br><br><span class="hljs-comment">// 建立f变量和函数的对应关系</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>) &#123;&#125;<br><br><span class="hljs-comment">// 建立f变量和函数的对应关系</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>) &#123;&#125;<br><span class="hljs-keyword">export</span> &#123;f&#125;<br></code></pre></td></tr></table></figure><p>需要注意的是，export可以出现在模块的任何位置，只要处于模块的顶层，如果处于块级作用域，将会报错</p><p>使用了export命令定义了模块的对外接口后，其他的模块可以通过import命令加载这个模块</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// b.js</span><br><span class="hljs-keyword">import</span> &#123;name, age&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;a.js&#x27;</span><br><br><span class="hljs-comment">// 重命名</span><br><span class="hljs-keyword">import</span> &#123;name <span class="hljs-keyword">as</span> nameNew, age&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;a.js&#x27;</span><br></code></pre></td></tr></table></figure><p>要注意，import命令具有提升效果，会放到整个模块的顶部，首先执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name)<br><span class="hljs-keyword">import</span> &#123;name&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;a.js&#x27;</span><br></code></pre></td></tr></table></figure><p>因为import命令是编译阶段执行的，在代码运行之前</p><p>由于import是静态执行，所以不可以使用表达式和变量（他们只能在代码运行的时候才有具体的结果）</p><p>我们还可以整体加载</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> a <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;a.js&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-property">name</span>) <span class="hljs-comment">// shiyuq</span><br></code></pre></td></tr></table></figure><p>从上面可以看出使用import的时候，用户需要知道所要加载的变量名或者函数名，否则无法加载，所以为了方便用户，我们可以使用<code>export default</code>命令</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// a.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;shiyuq&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>上面是默认输出的一个匿名函数，我们可以在其他模块中这么使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> a <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;a.js&#x27;</span><br><span class="hljs-title function_">a</span>() <span class="hljs-comment">// shiyuq</span><br></code></pre></td></tr></table></figure><p>所以我们常常会在源码中看到以下代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> _ <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;lodash&#x27;</span><br><br><span class="hljs-comment">// 同时输入默认方法和其他变量</span><br><span class="hljs-keyword">import</span> _, &#123;each&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;lodash&#x27;</span><br><br><span class="hljs-comment">//对应的export语句</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">obj</span>) &#123;&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">each</span>(<span class="hljs-params">obj, iterator, context</span>) &#123;&#125;<br><br><span class="hljs-keyword">export</span> &#123;each <span class="hljs-keyword">as</span> forEach&#125;<br><br><span class="hljs-comment">// 如果你想输出默认值</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-number">18</span><br><span class="hljs-comment">// 这里实际是有一个default变量，然后把18赋值给了变量default，所以没有报错</span><br></code></pre></td></tr></table></figure><h4 id="模块加载的实质"><a href="#模块加载的实质" class="headerlink" title="模块加载的实质"></a>模块加载的实质</h4><p>CommonJS模块输出的是一个值的浅拷贝，而ES6模块输出的是值的引用，它在遇到import命令时，不去执行模块，而是生成一个动态的只读引用，等真的需要用到的时候再去模块中取值，所以ES6时动态引用，并不会缓存值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 举个栗子</span><br><span class="hljs-keyword">let</span> name = <span class="hljs-string">&#x27;shiyuq&#x27;</span> <span class="hljs-comment">// 值引用</span><br><span class="hljs-keyword">const</span> <span class="hljs-built_in">exports</span> = &#123;<span class="hljs-attr">name</span>: name&#125; <span class="hljs-comment">// 此时开辟了一个堆内存存储并且赋值给exports变量</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">exports</span>.<span class="hljs-property">name</span>) <span class="hljs-comment">// shiyuq</span><br><span class="hljs-built_in">exports</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;jenny&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">exports</span>.<span class="hljs-property">name</span>) <span class="hljs-comment">// jenny</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name) <span class="hljs-comment">// shiyuq</span><br><br><span class="hljs-comment">// 再看一个</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable language_">module</span> = &#123;<span class="hljs-attr">exports</span>: &#123;&#125;&#125;<br><span class="hljs-keyword">const</span> moduleA = (<span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable language_">module</span>, <span class="hljs-built_in">exports</span>, <span class="hljs-built_in">require</span></span>) &#123;<br>    <span class="hljs-keyword">let</span> name = <span class="hljs-string">&#x27;shiyuq&#x27;</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">setName</span> = (<span class="hljs-params">n</span>) =&gt; name = n<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">getName</span> = (<span class="hljs-params"></span>) =&gt; name<br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>name,<br>        setName,<br>        getName<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span><br>&#125;)(<span class="hljs-variable language_">module</span>, <span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>, &#123;&#125;)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(moduleA) <span class="hljs-comment">// &#123;name: &#x27;shiyuq&#x27;, getName: f, setName: f&#125;</span><br><br>moduleA.<span class="hljs-title function_">getName</span>() <span class="hljs-comment">// shiyuq</span><br>moduleA.<span class="hljs-property">name</span> <span class="hljs-comment">// shiyuq</span><br><br>moduleA.<span class="hljs-title function_">setName</span>(<span class="hljs-string">&#x27;jenny&#x27;</span>)<br>moduleA.<span class="hljs-title function_">getName</span>() <span class="hljs-comment">// jenny</span><br>moduleA.<span class="hljs-property">name</span> <span class="hljs-comment">// shiyuq</span><br></code></pre></td></tr></table></figure><p>现在大家应该了解了为什么内部的变化不会影响到外部的值了，但是这个也仅仅只是针对的原始值，如果是引用值那就会跟着变化了</p><p>但是ES6的模块运行机制和CommonJS不一样，它在遇到import时，只是生成一个动态的只读引用，有点像linux里面的软链接，如果原始值变了，import输入的值也会跟着变化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// a.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> counter = <span class="hljs-number">3</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">incCounter</span>(<span class="hljs-params"></span>) &#123;<br>    counter++<br>&#125;<br><br><span class="hljs-comment">// b.js</span><br><span class="hljs-keyword">import</span> &#123;counter, incCounter&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;a.js&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(counter) <span class="hljs-comment">// 3</span><br><span class="hljs-title function_">incCounter</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(counter) <span class="hljs-comment">// 4</span><br></code></pre></td></tr></table></figure><p>可见ES6模块不会缓存运行结果，而是动态获取</p><h4 id="ES6模块的循环加载"><a href="#ES6模块的循环加载" class="headerlink" title="ES6模块的循环加载"></a>ES6模块的循环加载</h4><p>ES6模块是动态引用，所以那些变量并不会被缓存，而是成为一个指向被加载模块的引用，只要你作为开发者能确保它真的能取到值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// a.js</span><br><span class="hljs-keyword">import</span> &#123;bar&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;b.js&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;a.js&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(bar)<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> foo = <span class="hljs-string">&#x27;foo&#x27;</span><br><br><span class="hljs-comment">// b.js</span><br><span class="hljs-keyword">import</span> &#123;foo&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;a.js&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;b.js&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo)<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> bar = <span class="hljs-string">&#x27;bar&#x27;</span><br></code></pre></td></tr></table></figure><p>上面a模块中引用b，b模块中引用a，造成循环引用，现在执行<code>node a.js</code>查看运行结果</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">b</span><span class="hljs-selector-class">.js</span><br>ReferenceError: foo is not defined<br></code></pre></td></tr></table></figure><p>这是因为在执行a模块的时候，其中引入了b模块，去b模块中加载，首先打印b.js，然后打印foo，但是此时a模块中并未输出foo接口，所以报错</p><p>大家也可以写一个 简单的demo，测试一下ES6打包后的代码，这样可以更加清晰的了解ES6和CommonJS的不同之处</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
